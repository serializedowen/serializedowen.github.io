{"componentChunkName":"component---src-templates-docs-js","path":"/docs","result":{"data":{"allMarkdownRemark":{"totalCount":23,"edges":[{"node":{"frontmatter":{"title":"快速开始","date":"09.05.2019","category":"docs"},"fields":{"slug":"/docs/react-router-dom/向导/快速开始"},"excerpt":"快速开始 想开始在项目中使用 react-router， 你需要一个 react web 项目。如果你需要搭建一个全新的项目，我们推荐使用 Create React App。 这是一个很棒的工具，并且对 react-router 的支持很好。 安装 你可以使用你喜欢的包管理器（npm 或者 yarn）从官方的 npm 源安装 react-router-dom。 示例…","timeToRead":4}},{"node":{"frontmatter":{"title":"核心组件","date":"08.05.2019","category":"docs"},"fields":{"slug":"/docs/react-router-dom/向导/核心组件"},"excerpt":"核心组件 react-router 中有三种主要类型的组件，分别是 路由： 如   路由匹配器： 如 ,  导航：如 , ,  通常，导航也称为路径变更器。 所有在 web 应用中使用的组件都应该从 react-router-dom 包中引入 路由 所有 react-router 应用的核心组件都是路由组件。 对于 web 应用，react-router-dom…","timeToRead":4}},{"node":{"frontmatter":{"title":"服务端渲染","date":"07.05.2019","category":"docs"},"fields":{"slug":"/docs/react-router-dom/向导/服务端渲染"},"excerpt":"服务端渲染 基础 在服务端渲染路由会和客户端渲染有略微的区别，（因为服务端渲染没有状态）。基本思想是，我们将路由包裹到无状态的中，而不是包含状态的。 我们从服务端请求中获得 url 参数并将它传给去做路径匹配。下一步，我们会讨论 context 属性。 当你在客户端渲染组件时，react-router 会往 history API…","timeToRead":5}},{"node":{"frontmatter":{"title":"代码分割","date":"06.05.2019","category":"docs"},"fields":{"slug":"/docs/react-router-dom/向导/代码分割"},"excerpt":"代码分割 基础 web 应用的一个很大优势就是用户不需要在使用前去下载整个软件包。你可以把代码分割当做渐进式的应用下载。为了达成这项目的，我们会使用 webpack, @babel/plugin-syntax-dynamic-import, 和 loadable-components。 webpack 已经提供了内置的动态模块加载支持了；但是，如果你在使用 Babel(将 JSX…","timeToRead":2}},{"node":{"frontmatter":{"title":"滚动回溯","date":"05.05.2019","category":"docs"},"fields":{"slug":"/docs/react-router-dom/向导/滚动回溯"},"excerpt":"滚动回溯 在早版本的 react-router 中，我们提供了开箱即用的滚动回溯，从那时候开始用户们就一直在要求它。希望本文能够让你获得你需要的信息！ 浏览器对 history.pushState 会以普通浏览器导航相同的方式自行处理滚动恢复。它已经可以在 chrome…","timeToRead":4}},{"node":{"frontmatter":{"title":"代码哲学","date":"04.05.2019","category":"docs"},"fields":{"slug":"/docs/react-router-dom/向导/代码哲学"},"excerpt":"代码哲学 本指南的目的是解释使用 React Router 时要具有的思维模型。我们称之为“动态路由”，它与您可能更熟悉的“静态路由”完全不同。 静态路由 如果您使用过 Rails，Express，Ember，Angular 等，则使用了静态路由。在这些框架中，您将在进行任何渲染之前将路由声明为应用程序初始化的一部分。React Router pre-v…","timeToRead":6}},{"node":{"frontmatter":{"title":"测试","date":"03.05.2019","category":"docs"},"fields":{"slug":"/docs/react-router-dom/向导/测试"},"excerpt":"测试 react-router 依赖 React.context 来正常工作。这会影响你测试组件的方法。 Context 如果尝试对渲染或等的组件之一进行单元测试，则会收到一些有关 Context 的错误和警告。虽然你会倾向于替换掉路由器的 context，我们建议您将测试用例用基础路由包裹，或者，或者（如果 window.history…","timeToRead":4}},{"node":{"frontmatter":{"title":"深度redux整合","date":"02.05.2019","category":"docs"},"fields":{"slug":"/docs/react-router-dom/向导/深度redux整合"},"excerpt":"深度 redux 整合 Redux 是 React 生态系统的重要组成部分。对于想要同时使用 React Router 和 Redux 的人，我们希望使其无缝集成。为此，有些人希望： 与 store 同步路由数据，并从 store 访问路由数据。 通过 action 来控制路由导航。 支持时间旅行调试模式 所有这些都需要更深入的集成。 而我们的推荐是：完全不在 redux…","timeToRead":1}},{"node":{"frontmatter":{"title":"静态路由","date":"01.05.2019","category":"docs"},"fields":{"slug":"/docs/react-router-dom/向导/静态路由"},"excerpt":"静态路由 以前版本的 React Router 使用静态路由来配置应用程序的路由。这样可以在渲染之前检查和匹配路线。由于 v4 转移到动态组件而不是路由配置，因此一些以前的用例变得不那么明显和棘手。我们正在开发一个用于静态路由配置和 React Router 的软件包，以继续满足这些用例。现在正在开发中，但我们希望您能尝试一下并提供帮助。 React Router Config","timeToRead":1}},{"node":{"frontmatter":{"title":"基础","date":"15.04.2019","category":"docs"},"fields":{"slug":"/docs/react-router-dom/示例/基础"},"excerpt":"基础","timeToRead":1}},{"node":{"frontmatter":{"title":"配置 URL 参数","date":"13.04.2019","category":"docs"},"fields":{"slug":"/docs/react-router-dom/示例/配置-url-参数"},"excerpt":"配置 URL 参数","timeToRead":1}},{"node":{"frontmatter":{"title":"嵌套路由","date":"12.04.2019","category":"docs"},"fields":{"slug":"/docs/react-router-dom/示例/嵌套路由"},"excerpt":"嵌套路由","timeToRead":1}},{"node":{"frontmatter":{"title":"重定向（鉴权）","date":"11.04.2019","category":"docs"},"fields":{"slug":"/docs/react-router-dom/示例/重定向（鉴权）"},"excerpt":"重定向（鉴权）","timeToRead":1}},{"node":{"frontmatter":{"title":"自定义 Link","date":"10.04.2019","category":"docs"},"fields":{"slug":"/docs/react-router-dom/示例/自定义-link"},"excerpt":"自定义 Link","timeToRead":1}},{"node":{"frontmatter":{"title":"防止过渡动画","date":"09.04.2019","category":"docs"},"fields":{"slug":"/docs/react-router-dom/示例/防止过渡动画"},"excerpt":"防止过渡动画","timeToRead":1}},{"node":{"frontmatter":{"title":"404 页面","date":"08.04.2019","category":"docs"},"fields":{"slug":"/docs/react-router-dom/示例/404-页面"},"excerpt":"404 页面","timeToRead":1}},{"node":{"frontmatter":{"title":"侧边栏","date":"06.04.2019","category":"docs"},"fields":{"slug":"/docs/react-router-dom/示例/侧边栏"},"excerpt":"侧边栏","timeToRead":1}},{"node":{"frontmatter":{"title":"动画过渡","date":"05.04.2019","category":"docs"},"fields":{"slug":"/docs/react-router-dom/示例/动画过渡"},"excerpt":"动画过渡","timeToRead":1}},{"node":{"frontmatter":{"title":"路由配置","date":"04.04.2019","category":"docs"},"fields":{"slug":"/docs/react-router-dom/示例/路由配置"},"excerpt":"路由配置","timeToRead":1}},{"node":{"frontmatter":{"title":"弹窗路由（Modal）","date":"03.04.2019","category":"docs"},"fields":{"slug":"/docs/react-router-dom/示例/弹窗路由（-modal）"},"excerpt":"弹窗路由 (Modal)","timeToRead":1}},{"node":{"frontmatter":{"title":"StaticRouter 上下文","date":"02.04.2019","category":"docs"},"fields":{"slug":"/docs/react-router-dom/示例/static-router-上下文"},"excerpt":"StaticRouter 上下文","timeToRead":1}},{"node":{"frontmatter":{"title":"递归路径","date":"01.04.2019","category":"docs"},"fields":{"slug":"/docs/react-router-dom/示例/递归路径"},"excerpt":"递归路径","timeToRead":1}},{"node":{"frontmatter":{"title":"页面查询参数","date":"01.04.2019","category":"docs"},"fields":{"slug":"/docs/react-router-dom/示例/页面查询参数"},"excerpt":"页面查询参数","timeToRead":1}}]}},"pageContext":{}},"staticQueryHashes":["3969440572","3969440572"]}