{"componentChunkName":"component---src-templates-post-js","path":"/location-配置详解","result":{"data":{"markdownRemark":{"html":"<p>这篇文章来源于自己网站的需求</p>\n<h3 id=\"location-模块的语法\" style=\"position:relative;\"><a href=\"#location-%E6%A8%A1%E5%9D%97%E7%9A%84%E8%AF%AD%E6%B3%95\" aria-label=\"location 模块的语法 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>location 模块的语法</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">location optional_modifier location_match {\n\n    . . .\n\n}</code></pre></div>\n<p>其中 optional_modifier 代表可选的 location 修饰符, 修饰符的存在或不存在会影响 Nginx 尝试匹配位置块的方式。解释如下：</p>\n<ul>\n<li>（无）：如果不存在修饰符，则该位置将解释为前缀匹配。这意味着给定的位置将与请求 URI 的开头进行匹配以确定是否匹配。</li>\n<li>=：如果使用等号，则只有在请求 URI 完全匹配给定的位置才会被被视为匹配。</li>\n<li>~：如果存在波浪号修饰符，则此位置将被解释为区分大小写的正则表达式匹配。</li>\n<li>~*：如果使用了波浪号和星号修饰符，则位置块将被解释为不区分大小写的正则表达式匹配。</li>\n<li>^~：如果存在克拉和波浪号修饰符，则表示如果当此项被选为最佳的非正则匹配时，其他正则匹配将不在有效。</li>\n</ul>\n<h4 id=\"语法示例\" style=\"position:relative;\"><a href=\"#%E8%AF%AD%E6%B3%95%E7%A4%BA%E4%BE%8B\" aria-label=\"语法示例 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>语法示例</h4>\n<p>下列是一个前缀匹配示例，他会匹配/site, /site/page1/index.html, /site/index.html 等等</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">location /site {\n    . . .\n}</code></pre></div>\n<p>下面则是一个绝对 URI 匹配，仅当请求地址和 location_match 完全相同时才会响应。他会匹配/page1，而不会匹配/page1/index.html：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">location = /page1 {\n    . . .\n}</code></pre></div>\n<p>下列配置会匹配<code class=\"language-text\">/tortoise.jpg</code> 但不会匹配<code class=\"language-text\">/FLOWER.PNG</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">location ~ \\.(jpe?g|png|gif|ico)$ {\n    . . .\n}</code></pre></div>\n<p>下列配置会匹配<code class=\"language-text\">/tortoise.jpg</code>和<code class=\"language-text\">/FLOWER.PNG</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">location ~* \\.(jpe?g|png|gif|ico)$ {\n    . . .\n}</code></pre></div>\n<h4 id=\"nginx-如何选择用哪个-location-模块-去响应请求\" style=\"position:relative;\"><a href=\"#nginx-%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E7%94%A8%E5%93%AA%E4%B8%AA-location-%E6%A8%A1%E5%9D%97-%E5%8E%BB%E5%93%8D%E5%BA%94%E8%AF%B7%E6%B1%82\" aria-label=\"nginx 如何选择用哪个 location 模块 去响应请求 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Nginx 如何选择用哪个 location 模块 去响应请求</h4>\n<p>Nginx 会使用一个固定的流程为您的请求选择最佳 location 模块，而这个流程和选择 server 模块的流程非常相似。理解它对正确配置和使用 Nginx 至关重要：</p>\n<ul>\n<li>首先 Nginx 会遍历所有的前缀匹配（所有不包含正则表达式的 location 模块）并尝试匹配请求 URI。</li>\n<li>第一步，Nginx 会寻找完全匹配项（包含 = 修饰符的 location 模块），如果找到，Nginx 将停止遍历并用当前匹配来响应请求。</li>\n<li>\n<p>如果没有找到完全匹配项，Nginx 接下来会去尝试寻找最长的非完全匹配项。</p>\n<ul>\n<li>如果最长匹配项中有 ^~ 修饰符，那么 Nginx 会立即终止接下来的查询并用当前 location 模块来响应请求</li>\n<li>如果不含^~ 修饰符，Nginx 会暂存当前 location 模块并继续搜索(使用栈来储存)</li>\n</ul>\n</li>\n<li>搜索完毕后，Nginx 按顺序依次匹配 location 模块中的正则表达式部分。如果正则表达式匹配，Nginx 会终止搜索并用当前 location 模块来响应请求。</li>\n<li>如果最长非完全匹配项中没有匹配的正则表达式，则此匹配项会出栈，开始匹配第二长的非完全匹配项</li>\n<li>搜索直到栈空，并返回 404 页面</li>\n</ul>\n<blockquote>\n<p>需要注意的是，尽管通常情况下 Nginx 会匹配最长，最详细的匹配，但正则表达式是按顺序匹配的，并且在匹配时会立即返回并使用，所以配置中正则表达式的定义顺序相当重要！</p>\n</blockquote>\n<h3 id=\"location-模块中的内部重定向\" style=\"position:relative;\"><a href=\"#location-%E6%A8%A1%E5%9D%97%E4%B8%AD%E7%9A%84%E5%86%85%E9%83%A8%E9%87%8D%E5%AE%9A%E5%90%91\" aria-label=\"location 模块中的内部重定向 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>location 模块中的内部重定向</h3>\n<p>一般来说，当一个 location 模块已被选择来响应请求时，该请求的响应内容肯定会定义在这个 location 模块的上下文中。而不会受到其他 location 模块的干扰。</p>\n<p>但有些情况下这并不满足我们的需求，所有 Nginx 为我们提供了一些内部重定向指令来触发新一轮的 location 模块匹配流程，这些指令是：</p>\n<ul>\n<li>index</li>\n<li>try_files</li>\n<li>rewrite</li>\n<li>error_page</li>\n</ul>\n<h4 id=\"index-指令\" style=\"position:relative;\"><a href=\"#index-%E6%8C%87%E4%BB%A4\" aria-label=\"index 指令 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>index 指令</h4>\n<p>如果你的配置中包含 index 指令，则匹配不到时总是会触发内部重定向。在下列例子中，我们用= 修饰符精确匹配来加快搜索过程，但当我们 location 模块中是个文件夹，并且找不到匹配项时，index 指令会内部重定向到第二个 location 模块来处理请求：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">index index.html;\nlocation = /exact {\n    . . .\n}\nlocation / {\n\n    . . .\n}</code></pre></div>\n<p>如果你要在这个例子中让匹配锁定在/exact 模块中，你可以进行下面的操作：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">location = /exact {\n    index nothing_will_match;  //一个肯定不会匹配的index项\n    autoindex on;\n}\nlocation  / {\n    . . .\n}</code></pre></div>\n<h4 id=\"try_files-指令\" style=\"position:relative;\"><a href=\"#try_files-%E6%8C%87%E4%BB%A4\" aria-label=\"try_files 指令 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>try_files 指令</h4>\n<p>try_files 指令同样会导致内部重定向，</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">root /var/www/main;\nlocation / {\n    try_files $uri $uri.html $uri/ /fallback/index.html;\n}\n\nlocation /fallback {\n    root /var/www/another;\n}</code></pre></div>\n<p>上述例子中，如果你请求/blahblah，第一个 location 模块会首先匹配并处理请求。它会尝试寻找在<code class=\"language-text\">/var/www/main</code>目录下寻找 <code class=\"language-text\">blahblah</code>文件，然后寻找<code class=\"language-text\">blahblah.html</code>文件，最后寻找<code class=\"language-text\">blahblah/</code>目录。如果这些匹配全部失败，会内部重定向到<code class=\"language-text\">/fallback/index.html</code>。这会触发第二次 location 搜索流程并匹配到第二个 location 模块中。</p>\n<h4 id=\"rewrite-指令\" style=\"position:relative;\"><a href=\"#rewrite-%E6%8C%87%E4%BB%A4\" aria-label=\"rewrite 指令 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>rewrite 指令</h4>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">root /var/www/main;\nlocation / {\n    rewrite ^/rewriteme/(.*)$ /$1 last;\n    try_files $uri $uri.html $uri/ /fallback/index.html;\n}\n\nlocation /fallback {\n    root /var/www/another;\n}</code></pre></div>\n<p>这个例子中，<code class=\"language-text\">/rewriteme/hello</code>会先被第一个 location 模块处理，他会被重写成<code class=\"language-text\">/hello</code> 并重新开始 location 搜索流程，<code class=\"language-text\">/hello</code>依然会匹配第一个 location 模块，并开始 try<em>files，如果 try</em>files 找不到匹配项，则会跳转到 <code class=\"language-text\">/fallback</code>location 模块中。</p>\n<h3 id=\"引用\" style=\"position:relative;\"><a href=\"#%E5%BC%95%E7%94%A8\" aria-label=\"引用 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>引用</h3>\n<ol>\n<li><a href=\"https://www.digitalocean.com/community/tutorials/understanding-nginx-server-and-location-block-selection-algorithms#matching-location-blocks\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Understanding Nginx Server and Location Block Selection Algorithms</a></li>\n</ol>","excerpt":"这篇文章来源于自己网站的需求 location 模块的语法 其中 optional_modifier 代表可选的 location 修饰符, 修饰符的存在或不存在会影响 Nginx…","frontmatter":{"title":"Location 配置详解","date":"15.10.2020","category":"Nginx"},"timeToRead":5}},"pageContext":{"slug":"/location-配置详解","prev":{"fileAbsolutePath":"/Users/owenwang/Documents/javascript/serializedowen.github.io/blog/breezing-effect.md","fields":{"slug":"/breezing-effect"},"sourceType":"posts","frontmatter":{"title":"breezing-effect","category":"CSS Tricks"}},"next":{"fileAbsolutePath":"/Users/owenwang/Documents/javascript/serializedowen.github.io/blog/docker/docker-compose入门.md","fields":{"slug":"/docker-compose入门"},"sourceType":"posts","frontmatter":{"title":"docker-compose入门","category":"Docker"}}}},"staticQueryHashes":["1124436713","4274079806"]}