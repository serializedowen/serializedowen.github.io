{"data":{"allMarkdownRemark":{"edges":[{"node":{"fields":{"slug":"/docker-compose入门"},"frontmatter":{"title":"docker-compose入门","date":"2020-10-21","category":"Docker"},"excerpt":"什么是 docker-compose 通俗的说，docker-compose 正如其名，是将你的多个 docker 容器服务整合起来的命令行工具。举个例子，假设你有一个 MySQL 实例和一个 Node.js 实例分别部署在两个容器中，仅需一个文件，docker-compose…","timeToRead":3}},{"node":{"fields":{"slug":"/location-配置详解"},"frontmatter":{"title":"Location 配置详解","date":"2020-10-15","category":"Nginx"},"excerpt":"这篇文章来源于自己网站的需求 location 模块的语法 其中 optional_modifier 代表可选的 location 修饰符, 修饰符的存在或不存在会影响 Nginx 尝试匹配位置块的方式。解释如下： （无）：如果不存在修饰符，则该位置将解释为前缀匹配。这意味着给定的位置将与请求 URI 的开头进行匹配以确定是否匹配。 =：如果使用等号，则只有在请求 URI…","timeToRead":5}},{"node":{"fields":{"slug":"/breezing-effect"},"frontmatter":{"title":"breezing-effect","date":"2020-09-18","category":"CSS Tricks"},"excerpt":"","timeToRead":1}},{"node":{"fields":{"slug":"/count-number-of-1-s"},"frontmatter":{"title":"Count number of 1s","date":"2020-09-17","category":"Algorithms"},"excerpt":"Count occurence of number 1s from 1 to an upperbound number Question Solution","timeToRead":1}},{"node":{"fields":{"slug":"/palindrome-with-length-limit"},"frontmatter":{"title":"Palindrome with length limit","date":"2020-09-16","category":"Algorithms"},"excerpt":"Question print all digit formed palindrome within length limit Solution","timeToRead":1}},{"node":{"fields":{"slug":"/get-tree-ancestor-ids"},"frontmatter":{"title":"Get tree ancestor ids","date":"2020-09-15","category":"Algorithms"},"excerpt":"answer","timeToRead":1}},{"node":{"fields":{"slug":"/polyfilling-global-this"},"frontmatter":{"title":"polyfilling globalThis","date":"2020-09-15","category":"ECMA Standards"},"excerpt":"定义 globalThis 提案引入了一种在任何 JavaScript 环境中访问全局变量的机制。听起来似乎是个很简单的 polyfill，但实际上实施起来我们遇到了诸多困难。 根据tc39 提案一个正确的 polyfill 应该具有以下几点要求： 必须在任何 JavaScript 环境下工作，包括浏览器，浏览器 web worker，浏览器插件，Node.js，Deno，和各种 js…","timeToRead":5}},{"node":{"fields":{"slug":"/code-transformation"},"frontmatter":{"title":"Code transformation","date":"2020-09-14","category":"Algorithms"},"excerpt":"target answer","timeToRead":1}},{"node":{"fields":{"slug":"/button-ripple-effect-w-simple-css"},"frontmatter":{"title":"Button ripple effect w/ simple css","date":"2020-09-10","category":"CSS Tricks"},"excerpt":"Google Material Design followed button ripple effect","timeToRead":1}},{"node":{"fields":{"slug":"/tap-tap-bug"},"frontmatter":{"title":"Tap Tap Bug","date":"2020-09-10","category":"Packages"},"excerpt":"A dead simple canvas game.","timeToRead":1}},{"node":{"fields":{"slug":"/frontend-watermarking-images"},"frontmatter":{"title":"Frontend watermarking images.","date":"2020-09-08","category":"Packages"},"excerpt":"vue-img-watermark Demo http://serializedowen.github.io/vue-img-watermark/ Installation Usage put  on your  tag to generate watermark for your image fully customizable with configuration object. use…","timeToRead":1}},{"node":{"fields":{"slug":"/ph-logo-generator"},"frontmatter":{"title":"ph-logo-generator","date":"2020-09-08","category":"Packages"},"excerpt":"Pornhub flavored logo generator. Demo available at Click Me!","timeToRead":1}},{"node":{"fields":{"slug":"/hot-reload-env-files"},"frontmatter":{"title":"Hot reload .env files","date":"2020-09-08","category":"Packages"},"excerpt":"vue-cli-plugin-envhot Seamlessly add .env file hot reloading support for your vue-cli based projects. Never worry about rebooting webpack-dev-server again. Features & Tips Reference Here for usage of…","timeToRead":1}},{"node":{"fields":{"slug":"/love-dispatcher-w-secrets"},"frontmatter":{"title":"Love Dispatcher w/ secrets","date":"2020-05-20","category":"Packages"},"excerpt":"crack your way through the game","timeToRead":1}},{"node":{"fields":{"slug":"/css-sticky-balls"},"frontmatter":{"title":"CSS Sticky Balls","date":"2019-08-21","category":"CSS Tricks"},"excerpt":"","timeToRead":1}},{"node":{"fields":{"slug":"/docs/react-router-dom/向导/快速开始"},"frontmatter":{"title":"快速开始","date":"2019-05-09","category":"docs"},"excerpt":"快速开始 想开始在项目中使用 react-router， 你需要一个 react web 项目。如果你需要搭建一个全新的项目，我们推荐使用 Create React App。 这是一个很棒的工具，并且对 react-router 的支持很好。 安装 你可以使用你喜欢的包管理器（npm 或者 yarn）从官方的 npm 源安装 react-router-dom。 示例…","timeToRead":4}},{"node":{"fields":{"slug":"/docs/react-router-dom/向导/核心组件"},"frontmatter":{"title":"核心组件","date":"2019-05-08","category":"docs"},"excerpt":"核心组件 react-router 中有三种主要类型的组件，分别是 路由： 如   路由匹配器： 如 ,  导航：如 , ,  通常，导航也称为路径变更器。 所有在 web 应用中使用的组件都应该从 react-router-dom 包中引入 路由 所有 react-router 应用的核心组件都是路由组件。 对于 web 应用，react-router-dom…","timeToRead":4}},{"node":{"fields":{"slug":"/docs/react-router-dom/向导/服务端渲染"},"frontmatter":{"title":"服务端渲染","date":"2019-05-07","category":"docs"},"excerpt":"服务端渲染 基础 在服务端渲染路由会和客户端渲染有略微的区别，（因为服务端渲染没有状态）。基本思想是，我们将路由包裹到无状态的中，而不是包含状态的。 我们从服务端请求中获得 url 参数并将它传给去做路径匹配。下一步，我们会讨论 context 属性。 当你在客户端渲染组件时，react-router 会往 history API…","timeToRead":5}},{"node":{"fields":{"slug":"/docs/react-router-dom/向导/代码分割"},"frontmatter":{"title":"代码分割","date":"2019-05-06","category":"docs"},"excerpt":"代码分割 基础 web 应用的一个很大优势就是用户不需要在使用前去下载整个软件包。你可以把代码分割当做渐进式的应用下载。为了达成这项目的，我们会使用 webpack, @babel/plugin-syntax-dynamic-import, 和 loadable-components。 webpack 已经提供了内置的动态模块加载支持了；但是，如果你在使用 Babel(将 JSX…","timeToRead":2}},{"node":{"fields":{"slug":"/docs/random/demo/示例"},"frontmatter":{"title":"示例","date":"2019-05-06","category":"docs"},"excerpt":"","timeToRead":1}},{"node":{"fields":{"slug":"/docs/react-router-dom/向导/滚动回溯"},"frontmatter":{"title":"滚动回溯","date":"2019-05-05","category":"docs"},"excerpt":"滚动回溯 在早版本的 react-router 中，我们提供了开箱即用的滚动回溯，从那时候开始用户们就一直在要求它。希望本文能够让你获得你需要的信息！ 浏览器对 history.pushState 会以普通浏览器导航相同的方式自行处理滚动恢复。它已经可以在 chrome…","timeToRead":4}},{"node":{"fields":{"slug":"/docs/react-router-dom/向导/设计理念"},"frontmatter":{"title":"设计理念","date":"2019-05-04","category":"docs"},"excerpt":"设计理念 本指南的目的是解释使用 React Router 时要具有的思维模型。我们称之为“动态路由”，它与您可能更熟悉的“静态路由”完全不同。 静态路由 如果您使用过 Rails，Express，Ember，Angular 等，则使用了静态路由。在这些框架中，您将在进行任何渲染之前的应用程序初始化过程中声明路由。React Router < v…","timeToRead":6}},{"node":{"fields":{"slug":"/docs/react-router-dom/向导/测试"},"frontmatter":{"title":"测试","date":"2019-05-03","category":"docs"},"excerpt":"测试 react-router 依赖 React.context 来正常工作。这会影响你测试组件的方法。 Context 如果尝试对渲染或等的组件之一进行单元测试，则会收到一些有关 Context 的错误和警告。虽然你会倾向于替换掉路由器的 context，我们建议您将测试用例用基础路由包裹，或者，或者（如果 window.history…","timeToRead":4}},{"node":{"fields":{"slug":"/docs/react-router-dom/向导/深度redux整合"},"frontmatter":{"title":"深度redux整合","date":"2019-05-02","category":"docs"},"excerpt":"深度 redux 整合 Redux 是 React 生态系统的重要组成部分。对于想要同时使用 React Router 和 Redux 的人，我们希望使其无缝集成。为此，有些人希望： 与 store 同步路由数据，并从 store 访问路由数据。 通过 action 来控制路由导航。 支持时间旅行调试模式 所有这些都需要更深入的集成。 而我们的推荐是：完全不在 redux…","timeToRead":1}},{"node":{"fields":{"slug":"/docs/react-router-dom/向导/静态路由"},"frontmatter":{"title":"静态路由","date":"2019-05-01","category":"docs"},"excerpt":"静态路由 以前版本的 React Router 使用静态路由来配置应用程序的路由。这样可以在渲染之前检查和匹配路线。由于 v4 转移到动态组件而不是路由配置，因此一些以前的用例变得不那么明显和棘手。我们正在开发一个用于静态路由配置和 React Router 的软件包，以继续满足这些用例。现在正在开发中，但我们希望您能尝试一下并提供帮助。 React Router Config","timeToRead":1}},{"node":{"fields":{"slug":"/docs/react-router-dom/示例/基础"},"frontmatter":{"title":"基础","date":"2019-04-15","category":"docs"},"excerpt":"基础","timeToRead":1}},{"node":{"fields":{"slug":"/docs/react-router-dom/"},"frontmatter":{"title":"","date":"2019-04-15","category":"docs"},"excerpt":"","timeToRead":1}},{"node":{"fields":{"slug":"/docs/random/"},"frontmatter":{"title":"","date":"2019-04-15","category":"docs"},"excerpt":"","timeToRead":1}},{"node":{"fields":{"slug":"/docs/react-router-dom/示例/配置-url-参数"},"frontmatter":{"title":"配置 URL 参数","date":"2019-04-13","category":"docs"},"excerpt":"配置 URL 参数","timeToRead":1}},{"node":{"fields":{"slug":"/docs/react-router-dom/示例/嵌套路由"},"frontmatter":{"title":"嵌套路由","date":"2019-04-12","category":"docs"},"excerpt":"嵌套路由","timeToRead":1}},{"node":{"fields":{"slug":"/docs/react-router-dom/示例/重定向（鉴权）"},"frontmatter":{"title":"重定向（鉴权）","date":"2019-04-11","category":"docs"},"excerpt":"重定向（鉴权）","timeToRead":1}},{"node":{"fields":{"slug":"/docs/react-router-dom/示例/自定义-link"},"frontmatter":{"title":"自定义 Link","date":"2019-04-10","category":"docs"},"excerpt":"自定义 Link","timeToRead":1}},{"node":{"fields":{"slug":"/docs/react-router-dom/示例/防止过渡动画"},"frontmatter":{"title":"防止过渡动画","date":"2019-04-09","category":"docs"},"excerpt":"防止过渡动画","timeToRead":1}},{"node":{"fields":{"slug":"/docs/react-router-dom/示例/404-页面"},"frontmatter":{"title":"404 页面","date":"2019-04-08","category":"docs"},"excerpt":"404 页面","timeToRead":1}},{"node":{"fields":{"slug":"/docs/react-router-dom/示例/侧边栏"},"frontmatter":{"title":"侧边栏","date":"2019-04-06","category":"docs"},"excerpt":"侧边栏","timeToRead":1}},{"node":{"fields":{"slug":"/docs/react-router-dom/示例/动画过渡"},"frontmatter":{"title":"动画过渡","date":"2019-04-05","category":"docs"},"excerpt":"动画过渡","timeToRead":1}},{"node":{"fields":{"slug":"/docs/react-router-dom/示例/路由配置"},"frontmatter":{"title":"路由配置","date":"2019-04-04","category":"docs"},"excerpt":"路由配置","timeToRead":1}},{"node":{"fields":{"slug":"/docs/react-router-dom/示例/弹窗路由（-modal）"},"frontmatter":{"title":"弹窗路由（Modal）","date":"2019-04-03","category":"docs"},"excerpt":"弹窗路由 (Modal)","timeToRead":1}},{"node":{"fields":{"slug":"/docs/react-router-dom/示例/static-router-上下文"},"frontmatter":{"title":"StaticRouter 上下文","date":"2019-04-02","category":"docs"},"excerpt":"StaticRouter 上下文","timeToRead":1}},{"node":{"fields":{"slug":"/docs/react-router-dom/示例/递归路径"},"frontmatter":{"title":"递归路径","date":"2019-04-01","category":"docs"},"excerpt":"递归路径","timeToRead":1}},{"node":{"fields":{"slug":"/docs/react-router-dom/示例/页面查询参数"},"frontmatter":{"title":"页面查询参数","date":"2019-04-01","category":"docs"},"excerpt":"页面查询参数","timeToRead":1}},{"node":{"fields":{"slug":"/docs/react-router-dom/API/hooks"},"frontmatter":{"title":"Hooks","date":"2019-03-31","category":"docs"},"excerpt":"Hooks React router 为您提供了一些 hook，方便你在组件中随时取用 react-router 的状态和进行导航操作 注意：你必须使用 react@16.8+ 才能使用这些 hooks！ useHistory useLocation useParams useRouteMatch useHistory useHistory 钩子返回 history…","timeToRead":2}},{"node":{"fields":{"slug":"/docs/react-router-dom/API/browser-router"},"frontmatter":{"title":"<BrowserRouter>","date":"2019-03-30","category":"docs"},"excerpt":"一个使用 HTML5 history API 的（ pushState，replaceState 和 popstate 事件），让您的 UI 同步与 URL。 basename: string 所有导航的路径前缀。如果你的应用不是部署在根目录上，你需要把它设置为部署的相对地址。basename 属性应该有带有前缀，但不包括后缀 getUserConfirmation: func…","timeToRead":1}},{"node":{"fields":{"slug":"/docs/react-router-dom/API/hash-router"},"frontmatter":{"title":"<HashRouter>","date":"2019-03-29","category":"docs"},"excerpt":"一个使用 url 中的 hash 部分来导航的路由器。（window.location.hash)。 注意事项：hash history 不支持 location.key 或 location.state…","timeToRead":1}},{"node":{"fields":{"slug":"/docs/react-router-dom/API/link"},"frontmatter":{"title":"<Link>","date":"2019-03-29","category":"docs"},"excerpt":"为你的 web 应用提供声明式，高可用性的路由导航。 to: string 链接位置的字符串表示形式，是通过将位置的路径名，搜索 query 和 hash 属性连接在一起而创建的。 或 to: object 一个包含以下属性的对象： pathname: 链接地址的路径表示 search: 查询属性的字符串表示 hash: url 中的 hash 部分 state: location…","timeToRead":2}},{"node":{"fields":{"slug":"/docs/react-router-dom/API/nav-link"},"frontmatter":{"title":"<NavLink>","date":"2019-03-28","category":"docs"},"excerpt":"特殊版本的，它将在与当前 URL 匹配时将 css 样式属性添加到渲染的元素。 activeClassName: string 当路径匹配时 dom 元素获得的 class 名称，与元素原有的 className 组合 activeStyle: object 当路径匹配时获得的 css 样式 exact: bool 如果为 true，则仅当位置完全匹配时，才会应用 active 的 css…","timeToRead":2}},{"node":{"fields":{"slug":"/docs/react-router-dom/API/prompt"},"frontmatter":{"title":"<Prompt>","date":"2019-03-27","category":"docs"},"excerpt":"Re-exported from core Prompt","timeToRead":1}},{"node":{"fields":{"slug":"/docs/react-router-dom/API/redirect"},"frontmatter":{"title":"<Redirect>","date":"2019-03-26","category":"docs"},"excerpt":"渲染会导航到新位置。新位置将覆盖历史记录堆栈中的当前位置，就像服务器端重定向（HTTP 3xx）一样。 to: string 重定向到的 url，所以可以被path-to-regexp@^1.7.0 识别的 url 都能使用。所有在 from 中匹配到的 url 参数必须都被使用。 to: object 重定向到的 url，所以可以被path-to-regexp@^1.7.0 识别的 url…","timeToRead":2}},{"node":{"fields":{"slug":"/docs/react-router-dom/API/memory-router"},"frontmatter":{"title":"<MemoryRouter>","date":"2019-03-26","category":"docs"},"excerpt":"一个使用内存读写“URL”和历史记录的路由器（不读或写到地址栏）。在测试和非浏览器环境（例如 React Native）中很有用。 initialEntries: array 一个初始化 history 栈的数组，他们可以是带有 { pathname, search, hash, state } 属性的对象或者 url 字符串。 initialIndex: number…","timeToRead":1}},{"node":{"fields":{"slug":"/docs/react-router-dom/API/route"},"frontmatter":{"title":"<Route>","date":"2019-03-25","category":"docs"},"excerpt":"组件应该是 react-router-dom 包里最重要的，最值得去认真学习和使用的组件。它最基本的责任就是在 URL 和自己的路径对应时渲染 UI。 思考下列代码： 如果应用程序的位置是/，则 UI 层次结构会类似于： 如果应用程序的位置是/news，则 UI 层次结构会类似于： “ react-empty”注释只是 React null 渲染的实现细节。但这有助于我们说明 react…","timeToRead":6}},{"node":{"fields":{"slug":"/docs/react-router-dom/API/static-router"},"frontmatter":{"title":"<StaticRouter>","date":"2019-03-24","category":"docs"},"excerpt":"一种永远不会改变 location 的路由。 这个路由会在服务端渲染场景中有用（用户完全没有点击任何链接，因此也没有任何路由改变发生）。同样，他在单元测试场景中也很有用。\n下列是一个示例 node 服务器，他会在有上下文 url 时发送 302 状态码，并在其他情况下发送 html basename: string 所有导航的路径前缀。basename…","timeToRead":2}},{"node":{"fields":{"slug":"/docs/react-router-dom/API/router"},"frontmatter":{"title":"<Router>","date":"2019-03-24","category":"docs"},"excerpt":"所有路由器组件的通用底层接口。通常，应用将使用高级路由器之一代替：      使用底层路由器的最常见用例是将自定义历史记录与状态管理库（例如 Redux 或 Mobx）进行同步。请注意，这不是使用状态管理库与 React Router 的必须步骤，而仅用于深度集成。 history: object 导航使用的 history 对象 children: node 渲染的子组件","timeToRead":1}},{"node":{"fields":{"slug":"/docs/react-router-dom/API/switch"},"frontmatter":{"title":"<Switch>","date":"2019-03-23","category":"docs"},"excerpt":"渲染第一个和 location 匹配的子路由。 这与仅使用一堆有何不同？ 独特之处在于它仅渲染一条路由。相反，每个与位置匹配的内容都包含在内。考虑以下路由： 如果 URL 是 /about， 那么, , 和都会被同时渲染。这是符合设计目标的，因为这会允许我们把以多种方式结合在应用中，例如侧边栏，面包屑和引导标签等等。 但是，有时我们只想选择一个进行渲染。如果我们不在，/about…","timeToRead":2}},{"node":{"fields":{"slug":"/docs/react-router-dom/API/history"},"frontmatter":{"title":"history","date":"2019-03-22","category":"docs"},"excerpt":"翻译 ing 本文档中的术语“history”和“history 对象”指的是history软件包，它是 React Router 仅有的两个主要依赖项之一（除了 React 本身），它提供了几种不同的实现来管理各种环境中 JavaScript 的会话历史。 以及一下几个术语： \"browser history\": 特定于 DOM 的实现，在支持 HTML5 history API 的 Web…","timeToRead":1}},{"node":{"fields":{"slug":"/docs/react-router-dom/API/location"},"frontmatter":{"title":"location","date":"2019-03-21","category":"docs"},"excerpt":"location 对象表示应用程序现在所在的位置，您希望其运行的位置，甚至是以前的位置。看起来像这样： react router 会在以下几个场景中为您注入 location 对象： Route 组件中： Route 组件的 render 方法中： Route 组件的子组件中： withRoutor 高阶组件中：  你也可以在 history.location…","timeToRead":2}},{"node":{"fields":{"slug":"/docs/react-router-dom/API/match"},"frontmatter":{"title":"match","date":"2019-03-20","category":"docs"},"excerpt":"一个 match 对象如何匹配到 URL 的相关信息。match 对象包含以下属性： params: (object): 从路径动态段的 URL 解析的键/值对。 isExact: (boolean): 如果整个 URL 匹配是会是 true （没有不被匹配的后缀） path: (string): 用于匹配的路径模式，在构建嵌套时会有用。 url: (string): 匹配部分的 URL…","timeToRead":2}},{"node":{"fields":{"slug":"/docs/react-router-dom/API/match-path"},"frontmatter":{"title":"matchPath","date":"2019-03-19","category":"docs"},"excerpt":"","timeToRead":1}},{"node":{"fields":{"slug":"/docs/react-router-dom/API/with-router"},"frontmatter":{"title":"withRouter","date":"2019-03-18","category":"docs"},"excerpt":"你可以通过 withRouter 高阶组件 访问 history 对象的属性和最近匹配。withRouter 在每次重新渲染时都会更新最新的 match, location, 和 history 属性。 重要提示：withRouter 不像 React Redux 那样订阅位置更改 connect 以进行状态更改。而是在位置更改后从组件传播出来，然后重新渲染。这意味着，withRouter…","timeToRead":1}},{"node":{"fields":{"slug":"/ice-skiing"},"frontmatter":{"title":"Ice skiing","date":"2018-12-29","category":"Trips"},"excerpt":"Been looking forward to this Blue Mountain skiing trip for a while. Beautiful weather, lovely hotel, life doesnt get any better than this... Right?\n Until After about an hour waiting in line for our…","timeToRead":1}},{"node":{"fields":{"slug":"/test"},"frontmatter":{"title":"Test","date":"2018-12-25","category":"CSS Tricks"},"excerpt":"Use table layout to force Zwei flinke Boxer jagen die quirlige Eva und ihren Mops durch Sylt. Franz jagt im komplett verwahrlosten Taxi quer durch Bayern. Zwölf Boxkämpfer jagen Viktor quer über den…","timeToRead":3}},{"node":{"fields":{"slug":"/markdown-cheatsheet"},"frontmatter":{"title":"Markdown Cheatsheet","date":"2018-01-01","category":"General"},"excerpt":"View raw (TEST.md) This is a paragraph. Header 1 Header 2 Header 1 Header 2 Header 3 Header 4 Header 5 Header 6 Header 1 Header 2 Header 3 Header 4 Header 5 Header 6 Lorem ipsum dolor sit amet…","timeToRead":2}}]}}}