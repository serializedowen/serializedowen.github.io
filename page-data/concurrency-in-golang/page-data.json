{"componentChunkName":"component---src-templates-post-js","path":"/concurrency-in-golang","result":{"data":{"markdownRemark":{"html":"<h2 id=\"goroutine\" style=\"position:relative;\"><a href=\"#goroutine\" aria-label=\"goroutine permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>goroutine</h2>\n<blockquote>\n<p>golang 多线程操作和 Java 等语言需要实例化 Thread 不太相同。而是采用了轻量化的 goroutine 来实现：</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"golang\"><pre class=\"language-golang\"><code class=\"language-golang\">go func() {}()</code></pre></div>\n<p>语法上很像 JavaScript 中的 IIFE，直接定义一个匿名函数并执行。</p>\n<p>也可以这样：</p>\n<div class=\"gatsby-highlight\" data-language=\"golang\"><pre class=\"language-golang\"><code class=\"language-golang\">function test(str string) {\n    fmt.Println(str)\n}\ngo test(&#39;111&#39;)</code></pre></div>\n<p>被 go 修饰的方法调用会开启一个新的线程来并发执行。</p>\n<p>示例：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">package main\n\nimport (\n    &quot;fmt&quot;\n    &quot;time&quot;\n)\n\nfunc f(from string) {\n    for i := 0; i &lt; 3; i++ {\n        fmt.Println(from, &quot;:&quot;, i)\n    }\n}\n\nfunc main() {\n\n    f(&quot;direct&quot;)\n\n    go f(&quot;goroutine&quot;)\n\n    go func(msg string) {\n        fmt.Println(msg)\n    }(&quot;going&quot;)\n\n    time.Sleep(time.Second)\n    fmt.Println(&quot;done&quot;)\n}</code></pre></div>\n<p>输出：</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">$ go run goroutines.go\ndirect : 0\ndirect : 1\ndirect : 2\ngoroutine : 0\ngoing\ngoroutine : 1\ngoroutine : 2\ndone</code></pre></div>\n<p>上面只是简单介绍了一下怎么开启多线程，最重要的功能还是没有提到，线程之间要怎么通信呢？那就需要 golang 特有的 chan(channel)来发挥威力了</p>\n<h2 id=\"channel\" style=\"position:relative;\"><a href=\"#channel\" aria-label=\"channel permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>channel</h2>\n<h4 id=\"定义：\" style=\"position:relative;\"><a href=\"#%E5%AE%9A%E4%B9%89%EF%BC%9A\" aria-label=\"定义： permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>定义：</h4>\n<blockquote>\n<p>channel 是连接多个 goroutine 的管道，你可以往管道里发送数据，并在另一个 goroutine 中读取并消费这些值</p>\n</blockquote>\n<p>语法如下:</p>\n<div class=\"gatsby-highlight\" data-language=\"golang\"><pre class=\"language-golang\"><code class=\"language-golang\">test := make(chan string)</code></pre></div>\n<p>我们创建了一个 string 的 channel 并把它赋值给了 test</p>\n<p>接下来使用他，我们需要<code class=\"language-text\">&lt;-</code>二元操作符，如果这时候 channel 在左边，<code class=\"language-text\">test &lt;- val</code> 则表示往 channel 中输入一个值，反之如<code class=\"language-text\">val &lt;- test</code>（val 可省略）则表示从 channel 中读取一个值</p>\n<blockquote>\n<p>默认情况下 channel 是无缓冲区的，也就是说只有在有 goroutine 在等待从 channel 中消费数据的时候你才能往里面写入数据。\n例子：</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"golang\"><pre class=\"language-golang\"><code class=\"language-golang\">t := make(chan string)\n//代码会报错   fatal error: all goroutines are asleep - deadlock!\nt &lt;- &quot;1&quot;</code></pre></div>\n<p>如果你想创建一个有缓冲区的 channel 使用</p>\n<div class=\"gatsby-highlight\" data-language=\"golang\"><pre class=\"language-golang\"><code class=\"language-golang\">test := make(chan string, bufferSize)</code></pre></div>\n<p>例子：使用 chan 来模拟 Lock</p>\n<div class=\"gatsby-highlight\" data-language=\"golang\"><pre class=\"language-golang\"><code class=\"language-golang\">func doSomething() {\n    fmt.Println(&quot;work&quot;)\n}\nlock := make(chan bool, 1)\n\ngo func(){\n    doSomething()\n    time.Sleep(time.Second)\n    doSomething()\n    lock &lt;- true\n}()\n\n&lt;- lock\nfmt.Println(&#39;done&#39;)\n\n// 在这个示例中，同步的done打印会在打印两次work之后才执行</code></pre></div>\n<h2 id=\"waitgroup\" style=\"position:relative;\"><a href=\"#waitgroup\" aria-label=\"waitgroup permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>WaitGroup</h2>\n<p>如果你想要监听多个 goroutine 的完成情况，就我们现在已经学过的知识，你可能会第一时间想到类似如下的代码:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">func main() {\n    c := make(chan bool, 100)\n    for i := 0; i &lt; 100; i++ {\n        go func(i int) {\n            fmt.Println(i)\n            c &lt;- true\n        }(i)\n    }\n\n    for i := 0; i &lt; 100; i++ {\n        &lt;-c\n    }\n}</code></pre></div>\n<p>他能完成我们的任务，但是看起来显得啰嗦，也不直观。</p>\n<p>golang 标准库中其实已经为我们提供了处理此类情况的标准做法，那就是<code class=\"language-text\">sync.WaitGroup</code></p>\n<p>WaitGroup 有三个主要方法：</p>\n<ul>\n<li>Add(): 计数+1</li>\n<li>Done(): 计数-1</li>\n<li>Wait(): 阻塞当前线程直到计数器归零</li>\n</ul>\n<p>示例：</p>\n<div class=\"gatsby-highlight\" data-language=\"golang\"><pre class=\"language-golang\"><code class=\"language-golang\">package main\n\nimport (\n    &quot;fmt&quot;\n    &quot;sync&quot;\n    &quot;time&quot;\n)\n\nfunc worker(id int, wg *sync.WaitGroup) {\n\n    defer wg.Done()\n\n    fmt.Printf(&quot;Worker %d starting\\n&quot;, id)\n\n    time.Sleep(time.Second)\n    fmt.Printf(&quot;Worker %d done\\n&quot;, id)\n}\n\nfunc main() {\n\n    var wg sync.WaitGroup\n\n    for i := 1; i &lt;= 5; i++ {\n        wg.Add(1)\n        go worker(i, &amp;wg)\n    }\n\n    wg.Wait()\n}</code></pre></div>\n<blockquote>\n<p>特别注意：WaitGroup 不是引用类型，因此在 goroutine 中操作，必须传入 WaitGroup 的指针，而不是 WaitGroup 实例本身。</p>\n</blockquote>\n<h2 id=\"select-关键字\" style=\"position:relative;\"><a href=\"#select-%E5%85%B3%E9%94%AE%E5%AD%97\" aria-label=\"select 关键字 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Select 关键字</h2>\n<p>同时消费多个 channel 中的数据</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">package main\n\nimport (\n    &quot;fmt&quot;\n    &quot;time&quot;\n)\n\nfunc main() {\n\n    c1 := make(chan string)\n    c2 := make(chan string)\n\n    go func() {\n        time.Sleep(1 * time.Second)\n        c1 &lt;- &quot;one&quot;\n    }()\n    go func() {\n        time.Sleep(2 * time.Second)\n        c2 &lt;- &quot;two&quot;\n    }()\n\n    for i := 0; i &lt; 2; i++ {\n        select {\n        case msg1 := &lt;-c1:\n            fmt.Println(&quot;received&quot;, msg1)\n        case msg2 := &lt;-c2:\n            fmt.Println(&quot;received&quot;, msg2)\n        }\n    }\n}</code></pre></div>\n<p>References:</p>\n<ul>\n<li><a href=\"https://gobyexample.com/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">gobyexample</a></li>\n</ul>","excerpt":"goroutine golang 多线程操作和 Java 等语言需要实例化 Thread 不太相同。而是采用了轻量化的 goroutine 来实现： 语法上很像 JavaScript 中的 IIFE，直接定义一个匿名函数并执行。 也可以这样： 被 go…","frontmatter":{"title":"Concurrency in Golang","date":"23.03.2021","category":"Golang"},"timeToRead":3}},"pageContext":{"slug":"/concurrency-in-golang","prev":{"fileAbsolutePath":"/Users/owenwang/Documents/javascript/serializedowen.github.io/blog/How-I-cut-GTA-Online-loading-times-by-70%/index.md","fields":{"slug":"/how-i-cut-gta-online-loading-times-by-70"},"sourceType":"posts","frontmatter":{"title":"How I cut GTA Online loading times by 70%","category":"Game"}},"next":null}},"staticQueryHashes":["1124436713","4274079806"]}